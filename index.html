<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universal Serial Terminal (Desktop + Android)</title>
    <style>
        body { font-family: sans-serif; padding: 15px; background: #f0f2f5; }
        .card { background: white; padding: 20px; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); max-width: 900px; margin: auto; }
        .controls { display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 15px; align-items: center; }
        .signal-controls { display: flex; gap: 10px; margin: 15px 0; padding: 10px; background: #eee; border-radius: 5px; }
        #terminal { width: 100%; height: 300px; background: #1e1e1e; color: #00ff00; padding: 15px; overflow-y: auto; font-family: monospace; border-radius: 5px; margin-bottom: 10px; white-space: pre-wrap; box-sizing: border-box; }
        #debugLog { width: 100%; height: 100px; background: #333; color: #ffcc00; padding: 10px; font-size: 12px; overflow-y: auto; border-radius: 5px; margin-top: 10px; box-sizing: border-box; }
        button { padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; color: white; background: #007bff; }
        button:disabled { background: #ccc !important; cursor: not-allowed; }
        .btn-off { background: #6c757d; width: 80px; }
        .btn-on { background: #28a745; width: 80px; }
        input[type="text"] { padding: 10px; flex-grow: 1; border: 1px solid #ccc; border-radius: 4px; }
        .status { padding: 10px; margin-bottom: 10px; border-radius: 5px; background: #e3f2fd; border-left: 4px solid #2196f3; }
    </style>
</head>
<body>

    <div class="card">
        <h2>Serial Terminal (Universal)</h2>
        
        <div class="status" id="statusMsg">
            <strong>Status:</strong> Checking API support...
        </div>

        <div class="controls">
            <button id="connectBtn">Connect Device</button>
            <select id="baudrate">
                <option value="9600">9600</option>
                <option value="19200">19200</option>
                <option value="38400">38400</option>
                <option value="57600">57600</option>
                <option value="115200" selected>115200</option>
            </select>
            <select id="parity">
                <option value="none">None</option>
                <option value="even">Even</option>
                <option value="odd">Odd</option>
            </select>
            <button id="disconnectBtn" style="background:#dc3545;" disabled>Disconnect</button>
        </div>

        <div class="signal-controls">
            <div style="display:flex; align-items:center; gap:5px;">
                <label>DTR:</label>
                <button id="dtrBtn" class="btn-off" disabled>OFF</button>
            </div>
            <div style="display:flex; align-items:center; gap:5px;">
                <label>RTS:</label>
                <button id="rtsBtn" class="btn-off" disabled>OFF</button>
            </div>
            <button id="clearBtn" style="background:#6c757d; margin-left: auto;">Clear Terminal</button>
        </div>

        <div id="terminal">--- Waiting for Device ---</div>

        <div class="controls">
            <input type="text" id="inputLine" placeholder="Type command...">
            <button id="sendBtn" disabled>Send</button>
        </div>

        <strong>Debug Log:</strong>
        <div id="debugLog">System Initialized.</div>
    </div>

    <script>
        // Detect which API to use
        // On Android, force WebUSB even if Web Serial exists (Web Serial doesn't support USB devices on Android)
        const isAndroid = /Android/i.test(navigator.userAgent);
        const useWebSerial = 'serial' in navigator && !isAndroid;
        const useWebUSB = 'usb' in navigator && (isAndroid || !('serial' in navigator));
        
        // CH343/CH340 USB IDs
        const CH343_VENDOR_ID = 0x1A86;
        const USB_FILTERS = [
            { usbVendorId: 0x1A86, usbProductId: 0x55D3 }, // CH343
            { usbVendorId: 0x1A86, usbProductId: 0x55D4 }, // CH343G
            { usbVendorId: 0x1A86, usbProductId: 0x7523 }, // CH340
            { usbVendorId: 0x1A86 }                        // Any QinHeng
        ];

        // Web Serial API variables
        let port = null;
        let reader = null;
        let keepReading = false;

        // WebUSB API variables
        let device = null;
        let iface = null;
        let endpointIn = null;
        let endpointOut = null;

        // Common state
        let dtrState = false;
        let rtsState = false;
        let currentBaudRate = 115200;

        const debugLog = (msg) => {
            const log = document.getElementById('debugLog');
            const timestamp = new Date().toLocaleTimeString();
            log.innerText += `\n[${timestamp}] ${msg}`;
            log.scrollTop = log.scrollHeight;
        };

        const updateStatus = (msg, isError = false) => {
            const status = document.getElementById('statusMsg');
            status.innerHTML = `<strong>${isError ? 'Error' : 'Status'}:</strong> ${msg}`;
            status.style.background = isError ? '#ffebee' : '#e3f2fd';
            status.style.borderColor = isError ? '#f44336' : '#2196f3';
        };

        // Initialize
        if (useWebSerial) {
            updateStatus('Using Web Serial API (Desktop mode)');
            debugLog('Web Serial API detected - Desktop mode');
        } else if (useWebUSB) {
            updateStatus('Using WebUSB API (Android mode)');
            debugLog('WebUSB API detected - Android mode');
        } else {
            updateStatus('No compatible API available', true);
            debugLog('ERROR: Neither Web Serial nor WebUSB available');
            document.getElementById('connectBtn').disabled = true;
        }

        // ============================================
        // WEB SERIAL API (DESKTOP)
        // ============================================
        async function connectWebSerial() {
            try {
                debugLog('Requesting serial port...');
                port = await navigator.serial.requestPort({ filters: USB_FILTERS });
                
                currentBaudRate = parseInt(document.getElementById('baudrate').value);
                const parityValue = document.getElementById('parity').value;
                
                debugLog(`Opening port: ${currentBaudRate} baud, ${parityValue} parity`);
                await port.open({
                    baudRate: currentBaudRate,
                    parity: parityValue,
                    dataBits: 8,
                    stopBits: 1
                });

                debugLog('Connected via Web Serial API');
                updateStatus('Connected successfully (Desktop mode)');
                keepReading = true;
                uiState(true);
                readLoopSerial();
            } catch (err) {
                updateStatus(`Connection failed: ${err.message}`, true);
                debugLog(`ERROR: ${err.message}`);
            }
        }

        async function readLoopSerial() {
            while (port && port.readable && keepReading) {
                reader = port.readable.getReader();
                try {
                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) break;
                        const text = new TextDecoder().decode(value);
                        document.getElementById('terminal').innerText += text;
                        document.getElementById('terminal').scrollTop = document.getElementById('terminal').scrollHeight;
                    }
                } catch (err) {
                    if (keepReading) {
                        debugLog(`Read error: ${err.message}`);
                    }
                } finally {
                    reader.releaseLock();
                    reader = null;
                }
            }
        }

        async function sendSerial(data) {
            if (!port || !port.writable) return;
            const writer = port.writable.getWriter();
            try {
                await writer.write(new TextEncoder().encode(data));
            } finally {
                writer.releaseLock();
            }
        }

        async function setSignalsSerial(dtr, rts) {
            if (port && port.writable) {
                try {
                    await port.setSignals({ dataTerminalReady: dtr, requestToSend: rts });
                    debugLog(`Signals: DTR=${dtr}, RTS=${rts}`);
                } catch (err) {
                    debugLog(`Signal error: ${err.message}`);
                }
            }
        }

        async function disconnectSerial() {
            debugLog('Disconnecting Web Serial...');
            keepReading = false;
            
            if (reader) {
                try {
                    await reader.cancel();
                } catch (err) {}
            }

            if (port) {
                try {
                    await port.close();
                    debugLog('Port closed');
                    
                    // Unpair the device so it can be selected again
                    if (port.forget) {
                        await port.forget();
                        debugLog('Device unpaired');
                    }
                } catch (err) {
                    debugLog(`Close error: ${err.message}`);
                }
                port = null;
            }
        }

        // ============================================
        // WEBUSB API (ANDROID) - CDC-ACM Protocol
        // ============================================
        // CDC-ACM Standard Request Codes
        const CDC_SET_LINE_CODING = 0x20;
        const CDC_GET_LINE_CODING = 0x21;
        const CDC_SET_CONTROL_LINE_STATE = 0x22;

        async function connectWebUSB() {
            try {
                debugLog('Requesting USB device...');
                device = await navigator.usb.requestDevice({
                    filters: [
                        { vendorId: CH343_VENDOR_ID, productId: 0x55D3 },
                        { vendorId: CH343_VENDOR_ID, productId: 0x55D4 },
                        { vendorId: CH343_VENDOR_ID, productId: 0x7523 },
                        { vendorId: CH343_VENDOR_ID }
                    ]
                });

                debugLog(`Device: ${device.productName || 'Unknown'} (VID:0x${device.vendorId.toString(16)} PID:0x${device.productId.toString(16)})`);

                await device.open();
                if (device.configuration === null) {
                    await device.selectConfiguration(1);
                }

                // Try to find the right interface with bulk endpoints
                let foundInterface = false;
                for (const intf of device.configuration.interfaces) {
                    debugLog(`Checking interface ${intf.interfaceNumber}...`);
                    
                    // CH343 CDC uses interface class 2 (Communications)
                    for (const alt of intf.alternates) {
                        const epIn = alt.endpoints.find(e => e.direction === 'in' && e.type === 'bulk');
                        const epOut = alt.endpoints.find(e => e.direction === 'out' && e.type === 'bulk');
                        
                        if (epIn && epOut) {
                            iface = intf;
                            await device.claimInterface(iface.interfaceNumber);
                            debugLog(`Interface ${iface.interfaceNumber} claimed (class: ${alt.interfaceClass})`);
                            
                            endpointIn = epIn;
                            endpointOut = epOut;
                            foundInterface = true;
                            debugLog(`Endpoints: IN=${endpointIn.endpointNumber}, OUT=${endpointOut.endpointNumber}`);
                            break;
                        }
                    }
                    if (foundInterface) break;
                }

                if (!foundInterface) {
                    throw new Error('No interface with bulk IN/OUT endpoints found');
                }

                // Set line coding (baud rate, stop bits, parity, data bits)
                currentBaudRate = parseInt(document.getElementById('baudrate').value);
                const parityValue = document.getElementById('parity').value;
                await cdcSetLineCoding(currentBaudRate, parityValue);

                updateStatus('Connected successfully (Android mode)');
                keepReading = true;
                uiState(true);
                readLoopUSB();

            } catch (err) {
                updateStatus(`Connection failed: ${err.message}`, true);
                debugLog(`ERROR: ${err.message}`);
            }
        }

        async function cdcSetLineCoding(baudRate, parityType = 'none') {
            try {
                // CDC Line Coding structure: 7 bytes
                // dwDTERate (4 bytes) - baud rate
                // bCharFormat (1 byte) - stop bits (0=1, 1=1.5, 2=2)
                // bParityType (1 byte) - parity (0=none, 1=odd, 2=even, 3=mark, 4=space)
                // bDataBits (1 byte) - data bits (5,6,7,8)
                
                const lineCoding = new Uint8Array(7);
                // Baud rate (little-endian)
                lineCoding[0] = baudRate & 0xFF;
                lineCoding[1] = (baudRate >> 8) & 0xFF;
                lineCoding[2] = (baudRate >> 16) & 0xFF;
                lineCoding[3] = (baudRate >> 24) & 0xFF;
                lineCoding[4] = 0; // 1 stop bit
                
                // Parity mapping
                const parityMap = {
                    'none': 0,
                    'odd': 1,
                    'even': 2
                };
                lineCoding[5] = parityMap[parityType] || 0;
                lineCoding[6] = 8; // 8 data bits
                
                await device.controlTransferOut({
                    requestType: 'class',
                    recipient: 'interface',
                    request: CDC_SET_LINE_CODING,
                    value: 0,
                    index: iface.interfaceNumber
                }, lineCoding);
                
                debugLog(`Line coding: ${baudRate} baud, ${parityType} parity, 8N1`);
            } catch (err) {
                debugLog(`Set line coding error: ${err.message}`);
                throw err;
            }
        }

        async function readLoopUSB() {
            while (device && keepReading) {
                try {
                    const result = await device.transferIn(endpointIn.endpointNumber, 64);
                    
                    if (result.data && result.data.byteLength > 0) {
                        const text = new TextDecoder().decode(result.data);
                        document.getElementById('terminal').innerText += text;
                        document.getElementById('terminal').scrollTop = document.getElementById('terminal').scrollHeight;
                    }
                } catch (err) {
                    if (keepReading) {
                        debugLog(`Read error: ${err.message}`);
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
            }
        }

        async function sendUSB(data) {
            if (!device || !endpointOut) return;
            const encoded = new TextEncoder().encode(data);
            await device.transferOut(endpointOut.endpointNumber, encoded);
        }

        async function setSignalsUSB(dtr, rts) {
            if (!device) return;
            try {
                // CDC Control Line State
                // Bit 0: DTR
                // Bit 1: RTS
                const controlLineState = (dtr ? 0x01 : 0) | (rts ? 0x02 : 0);
                
                await device.controlTransferOut({
                    requestType: 'class',
                    recipient: 'interface',
                    request: CDC_SET_CONTROL_LINE_STATE,
                    value: controlLineState,
                    index: iface.interfaceNumber
                });
                
                debugLog(`Signals: DTR=${dtr}, RTS=${rts}`);
            } catch (err) {
                debugLog(`Signal error: ${err.message}`);
            }
        }

        async function disconnectUSB() {
            debugLog('Disconnecting WebUSB...');
            keepReading = false;

            if (device) {
                try {
                    if (iface) {
                        await device.releaseInterface(iface.interfaceNumber);
                    }
                    await device.close();
                    debugLog('Device closed');
                } catch (err) {
                    debugLog(`Close error: ${err.message}`);
                }
                device = null;
            }
        }

        // ============================================
        // UNIFIED INTERFACE
        // ============================================
        document.getElementById('connectBtn').onclick = async () => {
            if (useWebSerial) {
                await connectWebSerial();
            } else if (useWebUSB) {
                await connectWebUSB();
            }
        };

        document.getElementById('disconnectBtn').onclick = async () => {
            if (useWebSerial) {
                await disconnectSerial();
            } else if (useWebUSB) {
                await disconnectUSB();
            }
            updateStatus('Disconnected');
            uiState(false);
        };

        document.getElementById('sendBtn').onclick = async () => {
            const text = document.getElementById('inputLine').value + '\r\n';
            try {
                if (useWebSerial) {
                    await sendSerial(text);
                } else if (useWebUSB) {
                    await sendUSB(text);
                }
                debugLog(`Sent: ${text.trim()}`);
                document.getElementById('inputLine').value = '';
            } catch (err) {
                debugLog(`Send error: ${err.message}`);
            }
        };

        document.getElementById('dtrBtn').onclick = async function () {
            dtrState = !dtrState;
            this.className = dtrState ? "btn-on" : "btn-off";
            this.innerText = dtrState ? "ON" : "OFF";
            
            if (useWebSerial) {
                await setSignalsSerial(dtrState, rtsState);
            } else if (useWebUSB) {
                await setSignalsUSB(dtrState, rtsState);
            }
        };

        document.getElementById('rtsBtn').onclick = async function () {
            rtsState = !rtsState;
            this.className = rtsState ? "btn-on" : "btn-off";
            this.innerText = rtsState ? "ON" : "OFF";
            
            if (useWebSerial) {
                await setSignalsSerial(dtrState, rtsState);
            } else if (useWebUSB) {
                await setSignalsUSB(dtrState, rtsState);
            }
        };

        document.getElementById('clearBtn').onclick = () => {
            document.getElementById('terminal').innerText = "";
        };

        document.getElementById('inputLine').onkeypress = (e) => {
            if (e.key === 'Enter' && !document.getElementById('sendBtn').disabled) {
                document.getElementById('sendBtn').click();
            }
        };

        function uiState(connected) {
            document.getElementById('connectBtn').disabled = connected;
            document.getElementById('disconnectBtn').disabled = !connected;
            document.getElementById('sendBtn').disabled = !connected;
            document.getElementById('dtrBtn').disabled = !connected;
            document.getElementById('rtsBtn').disabled = !connected;
            document.getElementById('baudrate').disabled = connected;
            document.getElementById('parity').disabled = connected;
            
            if (!connected) {
                document.getElementById('terminal').innerText += "\n--- Disconnected ---";
            }
        }
    </script>
</body>
</html>
