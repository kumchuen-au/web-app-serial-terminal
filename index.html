<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universal Serial Terminal (Desktop + Android)</title>
    <style>
        body { font-family: sans-serif; padding: 15px; background: #f0f2f5; }
        .card { background: white; padding: 20px; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); max-width: 900px; margin: auto; }
        .controls { display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 15px; align-items: center; }
        .signal-controls { display: flex; gap: 10px; margin: 15px 0; padding: 10px; background: #eee; border-radius: 5px; }
        #terminal { width: 100%; height: 300px; background: #1e1e1e; color: #00ff00; padding: 15px; overflow-y: auto; font-family: monospace; border-radius: 5px; margin-bottom: 10px; white-space: pre-wrap; box-sizing: border-box; }
        #debugLog { width: 100%; height: 100px; background: #333; color: #ffcc00; padding: 10px; font-size: 12px; overflow-y: auto; border-radius: 5px; margin-top: 10px; box-sizing: border-box; }
        button { padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; color: white; background: #007bff; }
        button:disabled { background: #ccc !important; cursor: not-allowed; }
        .btn-off { background: #6c757d; width: 80px; }
        .btn-on { background: #28a745; width: 80px; }
        input[type="text"] { padding: 10px; flex-grow: 1; border: 1px solid #ccc; border-radius: 4px; }
        .status { padding: 10px; margin-bottom: 10px; border-radius: 5px; background: #e3f2fd; border-left: 4px solid #2196f3; }
    </style>
</head>
<body>

    <div class="card">
        <h2>Serial Terminal (Universal)</h2>
        
        <div class="status" id="statusMsg">
            <strong>Status:</strong> Checking API support...
        </div>

        <div class="controls">
            <button id="connectBtn">Connect Device</button>
            <select id="baudrate">
                <option value="9600">9600</option>
                <option value="19200">19200</option>
                <option value="38400">38400</option>
                <option value="57600">57600</option>
                <option value="115200" selected>115200</option>
            </select>
            <select id="parity">
                <option value="none">None</option>
                <option value="even">Even</option>
                <option value="odd">Odd</option>
            </select>
            <button id="disconnectBtn" style="background:#dc3545;" disabled>Disconnect</button>
        </div>

        <div class="signal-controls">
            <div style="display:flex; align-items:center; gap:5px;">
                <label>DTR:</label>
                <button id="dtrBtn" class="btn-off" disabled>OFF</button>
            </div>
            <div style="display:flex; align-items:center; gap:5px;">
                <label>RTS:</label>
                <button id="rtsBtn" class="btn-off" disabled>OFF</button>
            </div>
            <button id="clearBtn" style="background:#6c757d; margin-left: auto;">Clear Terminal</button>
        </div>

        <div id="terminal">--- Waiting for Device ---</div>

        <div class="controls">
            <input type="text" id="inputLine" placeholder="Type command...">
            <button id="sendBtn" disabled>Send</button>
        </div>

        <strong>Debug Log:</strong>
        <div id="debugLog">System Initialized.</div>
    </div>

    <script>
        // Detect which API to use
        // On Android, force WebUSB even if Web Serial exists (Web Serial doesn't support USB devices on Android)
        const isAndroid = /Android/i.test(navigator.userAgent);
        const useWebSerial = 'serial' in navigator && !isAndroid;
        const useWebUSB = 'usb' in navigator && (isAndroid || !('serial' in navigator));
        
        // CH343/CH340 USB IDs
        const CH343_VENDOR_ID = 0x1A86;
        const USB_FILTERS = [
            { usbVendorId: 0x1A86, usbProductId: 0x55D3 }, // CH343
            { usbVendorId: 0x1A86, usbProductId: 0x55D4 }, // CH343G
            { usbVendorId: 0x1A86, usbProductId: 0x7523 }, // CH340
            { usbVendorId: 0x1A86 }                        // Any QinHeng
        ];

        // Web Serial API variables
        let port = null;
        let reader = null;
        let keepReading = false;

        // WebUSB API variables
        let device = null;
        let iface = null;
        let endpointIn = null;
        let endpointOut = null;

        // Common state
        let dtrState = false;
        let rtsState = false;
        let currentBaudRate = 115200;

        const debugLog = (msg) => {
            const log = document.getElementById('debugLog');
            const timestamp = new Date().toLocaleTimeString();
            log.innerText += `\n[${timestamp}] ${msg}`;
            log.scrollTop = log.scrollHeight;
        };

        const updateStatus = (msg, isError = false) => {
            const status = document.getElementById('statusMsg');
            status.innerHTML = `<strong>${isError ? 'Error' : 'Status'}:</strong> ${msg}`;
            status.style.background = isError ? '#ffebee' : '#e3f2fd';
            status.style.borderColor = isError ? '#f44336' : '#2196f3';
        };

        // Initialize
        if (useWebSerial) {
            updateStatus('Using Web Serial API (Desktop mode)');
            debugLog('Web Serial API detected - Desktop mode');
        } else if (useWebUSB) {
            updateStatus('Using WebUSB API (Android mode)');
            debugLog('WebUSB API detected - Android mode');
        } else {
            updateStatus('No compatible API available', true);
            debugLog('ERROR: Neither Web Serial nor WebUSB available');
            document.getElementById('connectBtn').disabled = true;
        }

        // ============================================
        // WEB SERIAL API (DESKTOP)
        // ============================================
        async function connectWebSerial() {
            try {
                debugLog('Requesting serial port...');
                port = await navigator.serial.requestPort({ filters: USB_FILTERS });
                
                currentBaudRate = parseInt(document.getElementById('baudrate').value);
                const parityValue = document.getElementById('parity').value;
                
                debugLog(`Opening port: ${currentBaudRate} baud, ${parityValue} parity`);
                await port.open({
                    baudRate: currentBaudRate,
                    parity: parityValue,
                    dataBits: 8,
                    stopBits: 1
                });

                debugLog('Connected via Web Serial API');
                updateStatus('Connected successfully (Desktop mode)');
                keepReading = true;
                uiState(true);
                readLoopSerial();
            } catch (err) {
                updateStatus(`Connection failed: ${err.message}`, true);
                debugLog(`ERROR: ${err.message}`);
            }
        }

        async function readLoopSerial() {
            while (port && port.readable && keepReading) {
                reader = port.readable.getReader();
                try {
                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) break;
                        const text = new TextDecoder().decode(value);
                        document.getElementById('terminal').innerText += text;
                        document.getElementById('terminal').scrollTop = document.getElementById('terminal').scrollHeight;
                    }
                } catch (err) {
                    if (keepReading) {
                        debugLog(`Read error: ${err.message}`);
                    }
                } finally {
                    reader.releaseLock();
                    reader = null;
                }
            }
        }

        async function sendSerial(data) {
            if (!port || !port.writable) return;
            const writer = port.writable.getWriter();
            try {
                await writer.write(new TextEncoder().encode(data));
            } finally {
                writer.releaseLock();
            }
        }

        async function setSignalsSerial(dtr, rts) {
            if (port && port.writable) {
                try {
                    await port.setSignals({ dataTerminalReady: dtr, requestToSend: rts });
                    debugLog(`Signals: DTR=${dtr}, RTS=${rts}`);
                } catch (err) {
                    debugLog(`Signal error: ${err.message}`);
                }
            }
        }

        async function disconnectSerial() {
            debugLog('Disconnecting Web Serial...');
            keepReading = false;
            
            if (reader) {
                try {
                    await reader.cancel();
                } catch (err) {}
            }

            if (port) {
                try {
                    await port.close();
                    debugLog('Port closed');
                    
                    // Unpair the device so it can be selected again
                    if (port.forget) {
                        await port.forget();
                        debugLog('Device unpaired');
                    }
                } catch (err) {
                    debugLog(`Close error: ${err.message}`);
                }
                port = null;
            }
        }

        // ============================================
        // WEBUSB API (ANDROID) - CDC-ACM Protocol
        // ============================================
        // CDC-ACM Standard Request Codes
        const CDC_SET_LINE_CODING = 0x20;
        const CDC_GET_LINE_CODING = 0x21;
        const CDC_SET_CONTROL_LINE_STATE = 0x22;

        async function connectWebUSB() {
            try {
                debugLog('Requesting USB device...');
                device = await navigator.usb.requestDevice({
                    filters: [
                        { vendorId: CH343_VENDOR_ID, productId: 0x55D3 },
                        { vendorId: CH343_VENDOR_ID, productId: 0x55D4 },
                        { vendorId: CH343_VENDOR_ID, productId: 0x7523 },
                        { vendorId: CH343_VENDOR_ID }
                    ]
                });

                debugLog(`Device: ${device.productName || 'Unknown'} (VID:0x${device.vendorId.toString(16)} PID:0x${device.productId.toString(16)})`);

                await device.open();
                if (device.configuration === null) {
                    await device.selectConfiguration(1);
                }

                // CDC devices typically have 2 interfaces: control (0) and data (1)
                // We need to claim both
                let controlInterface = null;
                let dataInterface = null;
                
                for (const intf of device.configuration.interfaces) {
                    debugLog(`Checking interface ${intf.interfaceNumber}, class: ${intf.alternates[0].interfaceClass}`);
                    
                    // Interface class 2 = CDC Communications (control)
                    // Interface class 10 = CDC Data
                    if (intf.alternates[0].interfaceClass === 2) {
                        controlInterface = intf;
                        await device.claimInterface(intf.interfaceNumber);
                        debugLog(`Claimed control interface ${intf.interfaceNumber}`);
                    } else if (intf.alternates[0].interfaceClass === 10) {
                        dataInterface = intf;
                        await device.claimInterface(intf.interfaceNumber);
                        debugLog(`Claimed data interface ${intf.interfaceNumber}`);
                    }
                }
                
                if (!controlInterface || !dataInterface) {
                    throw new Error('Could not find both CDC control and data interfaces');
                }
                
                // Use control interface for commands, data interface for bulk transfers
                iface = controlInterface;
                
                // Get endpoints from data interface
                const dataAlt = dataInterface.alternates[0];
                endpointIn = dataAlt.endpoints.find(e => e.direction === 'in' && e.type === 'bulk');
                endpointOut = dataAlt.endpoints.find(e => e.direction === 'out' && e.type === 'bulk');

                if (!endpointIn || !endpointOut) {
                    throw new Error('Could not find bulk IN/OUT endpoints on data interface');
                }

                debugLog(`Endpoints: IN=${endpointIn.endpointNumber}, OUT=${endpointOut.endpointNumber}`);

                // Set line coding (baud rate, stop bits, parity, data bits)
                currentBaudRate = parseInt(document.getElementById('baudrate').value);
                const parityValue = document.getElementById('parity').value;
                await cdcSetLineCoding(currentBaudRate, parityValue);
                
                // Verify the settings by reading them back
                await cdcGetLineCoding();

                updateStatus('Connected successfully (Android mode)');
                keepReading = true;
                uiState(true);
                readLoopUSB();

            } catch (err) {
                updateStatus(`Connection failed: ${err.message}`, true);
                debugLog(`ERROR: ${err.message}`);
            }
        }

        async function cdcSetLineCoding(baudRate, parityType = 'none') {
            try {
                // CDC Line Coding structure: 7 bytes
                // dwDTERate (4 bytes) - baud rate (little-endian)
                // bCharFormat (1 byte) - stop bits (0=1, 1=1.5, 2=2)
                // bParityType (1 byte) - parity (0=none, 1=odd, 2=even, 3=mark, 4=space)
                // bDataBits (1 byte) - data bits (5,6,7,8)
                
                const lineCoding = new Uint8Array(7);
                // Baud rate (little-endian)
                lineCoding[0] = baudRate & 0xFF;
                lineCoding[1] = (baudRate >> 8) & 0xFF;
                lineCoding[2] = (baudRate >> 16) & 0xFF;
                lineCoding[3] = (baudRate >> 24) & 0xFF;
                lineCoding[4] = 0; // 1 stop bit
                
                // Parity mapping
                const parityMap = {
                    'none': 0,
                    'odd': 1,
                    'even': 2
                };
                lineCoding[5] = parityMap[parityType] || 0;
                lineCoding[6] = 8; // 8 data bits
                
                debugLog(`Setting line coding bytes: [${Array.from(lineCoding).map(b => '0x' + b.toString(16).padStart(2, '0')).join(', ')}]`);
                
                await device.controlTransferOut({
                    requestType: 'class',
                    recipient: 'interface',
                    request: CDC_SET_LINE_CODING,
                    value: 0,
                    index: iface.interfaceNumber
                }, lineCoding);
                
                // Also activate DTR and RTS to enable communication
                await device.controlTransferOut({
                    requestType: 'class',
                    recipient: 'interface',
                    request: CDC_SET_CONTROL_LINE_STATE,
                    value: 0x03, // DTR=1, RTS=1
                    index: iface.interfaceNumber
                });
                
                debugLog(`✓ Set: ${baudRate} baud, ${parityType} parity, 8N1, DTR+RTS active`);
            } catch (err) {
                debugLog(`Set line coding error: ${err.message}`);
                throw err;
            }
        }

        async function cdcGetLineCoding() {
            try {
                const result = await device.controlTransferIn({
                    requestType: 'class',
                    recipient: 'interface',
                    request: CDC_GET_LINE_CODING,
                    value: 0,
                    index: iface.interfaceNumber
                }, 7);
                
                if (result.data && result.data.byteLength === 7) {
                    const data = new Uint8Array(result.data.buffer);
                    const baudRate = data[0] | (data[1] << 8) | (data[2] << 16) | (data[3] << 24);
                    const stopBits = data[4];
                    const parity = data[5];
                    const dataBits = data[6];
                    
                    const parityNames = ['none', 'odd', 'even', 'mark', 'space'];
                    debugLog(`✓ Read back: ${baudRate} baud, ${parityNames[parity] || parity} parity, ${dataBits} data bits, ${stopBits} stop bits`);
                    
                    if (baudRate !== currentBaudRate) {
                        debugLog(`⚠ WARNING: Baud rate mismatch! Set ${currentBaudRate} but device reports ${baudRate}`);
                    }
                } else {
                    debugLog('Could not read line coding');
                }
            } catch (err) {
                debugLog(`Get line coding error: ${err.message}`);
            }
        }

        async function readLoopUSB() {
            while (device && keepReading) {
                try {
                    const result = await device.transferIn(endpointIn.endpointNumber, 64);
                    
                    if (result.data && result.data.byteLength > 0) {
                        const text = new TextDecoder().decode(result.data);
                        document.getElementById('terminal').innerText += text;
                        document.getElementById('terminal').scrollTop = document.getElementById('terminal').scrollHeight;
                    }
                } catch (err) {
                    if (keepReading) {
                        debugLog(`Read error: ${err.message}`);
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
            }
        }

        async function sendUSB(data) {
            if (!device || !endpointOut) return;
            const encoded = new TextEncoder().encode(data);
            await device.transferOut(endpointOut.endpointNumber, encoded);
        }

        async function setSignalsUSB(dtr, rts) {
            if (!device) return;
            try {
                // CDC Control Line State
                // Bit 0: DTR
                // Bit 1: RTS
                const controlLineState = (dtr ? 0x01 : 0) | (rts ? 0x02 : 0);
                
                await device.controlTransferOut({
                    requestType: 'class',
                    recipient: 'interface',
                    request: CDC_SET_CONTROL_LINE_STATE,
                    value: controlLineState,
                    index: iface.interfaceNumber
                });
                
                debugLog(`Signals: DTR=${dtr}, RTS=${rts}`);
            } catch (err) {
                debugLog(`Signal error: ${err.message}`);
            }
        }

        async function disconnectUSB() {
            debugLog('Disconnecting WebUSB...');
            keepReading = false;

            if (device) {
                try {
                    // Release both interfaces
                    for (const intf of device.configuration.interfaces) {
                        try {
                            await device.releaseInterface(intf.interfaceNumber);
                            debugLog(`Released interface ${intf.interfaceNumber}`);
                        } catch (err) {}
                    }
                    await device.close();
                    debugLog('Device closed');
                } catch (err) {
                    debugLog(`Close error: ${err.message}`);
                }
                device = null;
            }
        }

        // ============================================
        // UNIFIED INTERFACE
        // ============================================
        document.getElementById('connectBtn').onclick = async () => {
            if (useWebSerial) {
                await connectWebSerial();
            } else if (useWebUSB) {
                await connectWebUSB();
            }
        };

        document.getElementById('disconnectBtn').onclick = async () => {
            if (useWebSerial) {
                await disconnectSerial();
            } else if (useWebUSB) {
                await disconnectUSB();
            }
            updateStatus('Disconnected');
            uiState(false);
        };

        document.getElementById('sendBtn').onclick = async () => {
            const text = document.getElementById('inputLine').value + '\r\n';
            try {
                if (useWebSerial) {
                    await sendSerial(text);
                } else if (useWebUSB) {
                    await sendUSB(text);
                }
                debugLog(`Sent: ${text.trim()}`);
                document.getElementById('inputLine').value = '';
            } catch (err) {
                debugLog(`Send error: ${err.message}`);
            }
        };

        document.getElementById('dtrBtn').onclick = async function () {
            dtrState = !dtrState;
            this.className = dtrState ? "btn-on" : "btn-off";
            this.innerText = dtrState ? "ON" : "OFF";
            
            if (useWebSerial) {
                await setSignalsSerial(dtrState, rtsState);
            } else if (useWebUSB) {
                await setSignalsUSB(dtrState, rtsState);
            }
        };

        document.getElementById('rtsBtn').onclick = async function () {
            rtsState = !rtsState;
            this.className = rtsState ? "btn-on" : "btn-off";
            this.innerText = rtsState ? "ON" : "OFF";
            
            if (useWebSerial) {
                await setSignalsSerial(dtrState, rtsState);
            } else if (useWebUSB) {
                await setSignalsUSB(dtrState, rtsState);
            }
        };

        document.getElementById('clearBtn').onclick = () => {
            document.getElementById('terminal').innerText = "";
        };

        document.getElementById('inputLine').onkeypress = (e) => {
            if (e.key === 'Enter' && !document.getElementById('sendBtn').disabled) {
                document.getElementById('sendBtn').click();
            }
        };

        function uiState(connected) {
            document.getElementById('connectBtn').disabled = connected;
            document.getElementById('disconnectBtn').disabled = !connected;
            document.getElementById('sendBtn').disabled = !connected;
            document.getElementById('dtrBtn').disabled = !connected;
            document.getElementById('rtsBtn').disabled = !connected;
            document.getElementById('baudrate').disabled = connected;
            document.getElementById('parity').disabled = connected;
            
            if (!connected) {
                document.getElementById('terminal').innerText += "\n--- Disconnected ---";
            }
        }
    </script>
</body>
</html>
